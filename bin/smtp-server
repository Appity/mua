#!/usr/bin/env ruby

$LOAD_PATH << File.expand_path('../lib', __dir__)

require 'bundler'
require 'optparse'

Bundler.require(:default, ENV['APP_ENV']&.to_sym || :development)

require 'mua'
require 'async'
require 'logger'

# Async.logger.level = Logger::DEBUG

# == Main ===================================================================

options = {
  timeout: 30,
  silent: false
}

program = OptionParser.new do |opts|
  opts.on('-d', '--debug', 'Enable debug log of stream communcation')
  opts.on('-v', '--verbose', 'Enable versbose mode')
  opts.on('-s', '--silent', 'Suppress output')
  opts.on('-t', '--timeout=TIMEOUT', 'Set SMTP command timeout (seconds)', Integer)
end

program.parse!(ARGV, into: options)

if (options[:debug])
  Async::IO::Stream.prepend(Mua::Debug::StreamExtensions)
end

# TODO: Add Async::IO::Trap.new(:INT)
#       per https://github.com/socketry/async-io/blob/master/examples/echo/server.rb

Async do
  received = Hash.new do |h,k|
    h[k] = {
      messages: 0,
      bytes: 0
    }
  end

  server = Mua::SMTP::Server.new(timeout: options[:timeout]) do |context, state, event, *args|
    if (options[:verbose])
      puts('%s> %s' % [ context.remote_addr, event ])
    end

    case (event)
    when :deliver_accept
      received[context.id][:messages] += 1
      received[context.id][:bytes] += context.messages.last.data.bytesize
    when :disconnected
      cr = received[context.id]

      puts('%s> Received %d message(s) at %.1fMPS (%.1fMB/s)' % [
        context.remote_addr,
        cr[:messages],
        cr[:messages] / (Time.now - context.connected_at),
        (cr[:bytes] / (Time.now - context.connected_at)) / 1024**2
      ])
    end
  end

  unless (options[:silent])
    puts('SMTP server listening on %s:%d' % [ server.bind, server.port ])
  end
end
