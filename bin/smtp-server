#!/usr/bin/env ruby

$LOAD_PATH << File.expand_path('../lib', __dir__)

require 'bundler'
require 'optparse'

Bundler.require(:default, ENV['APP_ENV']&.to_sym || :development)

require 'mua'
require 'async'
require 'logger'

# Async.logger.level = Logger::DEBUG

# == Main ===================================================================

options = {
  listen: '127.0.0.1:1025',
  timeout: 30,
  silent: false
}

program = OptionParser.new do |opts|
  opts.on('-d', '--debug', 'Enable debug log of stream communcation')
  opts.on('-v', '--verbose', 'Enable versbose mode')
  opts.on('-s', '--silent', 'Suppress output')
  opts.on('-t', '--timeout TIMEOUT', 'Set SMTP command timeout (seconds)', Integer)
  opts.on('-r', '--random', 'Randomize behavior')
  opts.on('-l', '--listen LISTEN', 'Host/port to listen on (e.g. 127.0.0.1:1025')
  opts.on('--cert CERT', 'Base path to TLS certicificate/key pair (minus .pem and .crt extensions)')
end

program.parse!(ARGV, into: options)

if (options[:debug])
  if (options[:verbose] and !options[:silent])
    puts 'DEBUG: Adding debug shim to expose communications'
  end
  Async::IO::Stream.prepend(Mua::Debug::StreamExtensions)
end

# TODO: Add Async::IO::Trap.new(:INT)
#       per https://github.com/socketry/async-io/blob/master/examples/echo/server.rb

options[:bind], options[:port] = options[:listen].split(':')

if (options[:cert])
  options[:tls_key_path] = options[:cert] + '.pem'
  options[:tls_cert_path] = options[:cert] + '.crt'
end

begin
  Async::Reactor.run do
    received = Hash.new do |h,k|
      h[k] = {
        messages: 0,
        bytes: 0
      }
    end

    server = Mua::SMTP::Server.new(
      **options.slice(:bind, :port, :timeout, :tls_key_path, :tls_cert_path)
    ) do |context, state, event, *args|
      if (options[:verbose])
        puts('%s> %s %s' % [ context.remote_addr, state.name, event ])
      end

      case (event)
      when :connected
        puts('%s> Connection received' % [
          context.remote_addr
        ])
      when :deliver_accept
        message = args[0]
        received[context.id][:messages] += 1
        received[context.id][:bytes] += message.data.bytesize
      when :disconnected
        cr = received[context.id]
        delta = Time.now - context.connected_at

        puts('%s> Received %d message(s) in %.1fs at %.1fMPS (%.1fMB at %.1fMB/s)' % [
          context.remote_addr,
          cr[:messages],
          delta,
          cr[:messages] / delta,
          cr[:bytes] / 1024**2,
          (cr[:bytes] / delta) / 1024**2
        ])
      end
    end

    unless (options[:silent])
      puts('SMTP server listening on %s:%d' % [ server.bind, server.port ])

      if (server.tls_configured?)
        puts('* TLS configured and STARTTLS advertised')
      end
    end
  end

rescue Interrupt
  # Expected exit condition, just shut down.
  puts('Interrupt received. Terminating.')
  exit(0)
end
